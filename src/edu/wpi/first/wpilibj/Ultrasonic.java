/*----------------------------------------------------------------------------*/
/* Copyright (c) FIRST 2008-2012. All Rights Reserved.                        */
/* Open Source Software - may be modified and shared by FRC teams. The code   */
/* must be accompanied by the FIRST BSD license file in the root directory of */
/* the project.                                                               */
/*----------------------------------------------------------------------------*/

package edu.wpi.first.wpilibj;

import edu.wpi.first.wpilibj.livewindow.LiveWindowSendable;
import edu.wpi.first.wpilibj.tables.ITable;

/**
 * Ultrasonic rangefinder class. The Ultrasonic rangefinder measures absolute
 * distance based on the round-trip time of a ping generated by the controller.
 * These sensors use two transducers, a speaker and a microphone both tuned to
 * the ultrasonic range. A common ultrasonic sensor, the Daventech SRF04
 * requires a short pulse to be generated on a digital channel. This causes the
 * chirp to be emmitted. A second line becomes high as the ping is transmitted
 * and goes low when the echo is received. The time that the line is high
 * determines the round trip distance (time of flight).
 */
public class Ultrasonic extends SensorBase implements PIDSource, LiveWindowSendable {

	/**
	 * The units to return when PIDGet is called
	 */
	public static class Unit {

		/**
		 * The integer value representing this enumeration
		 */
		public final int value;
		static final int kInches_val = 0;
		static final int kMillimeters_val = 1;
		/**
		 * Use inches for PIDGet
		 */
		public static final Unit kInches = new Unit(kInches_val);
		/**
		 * Use millimeters for PIDGet
		 */
		public static final Unit kMillimeter = new Unit(kMillimeters_val);

		private Unit(int value) {
			this.value = value;
		}
	}

	private static final double kPingTime = 10 * 1e-6; // /< Time (sec) for the
														// ping trigger pulse.
	private static final double kMaxUltrasonicTime = 0.1; // /< Max time (ms)
															// between readings.
	private static final double kSpeedOfSoundInchesPerSec = 1130.0 * 12.0;

	private boolean m_allocatedChannels;
	private boolean m_enabled = false;
	private Unit m_units;
	
	private int pingOutputChannel;
	private int echoInputChannel;

	/**
	 * Initialize the Ultrasonic Sensor. This is the common code that
	 * initializes the ultrasonic sensor given that there are two digital I/O
	 * channels allocated. If the system was running in automatic mode (round
	 * robin) when the new sensor is added, it is stopped, the sensor is added,
	 * then automatic mode is restored.
	 */
	private synchronized void initialize()
	{
		m_enabled = true; // make it available for round robin scheduling
	}

	/**
	 * Create an instance of the Ultrasonic Sensor.
	 * This is designed to supchannel the Daventech SRF04 and Vex ultrasonic
	 * sensors.
	 *
	 * @param pingChannel
	 *            The digital output channel that sends the pulse to initiate
	 *            the sensor sending the ping.
	 * @param echoChannel
	 *            The digital input channel that receives the echo. The length
	 *            of time that the echo is high represents the round trip time
	 *            of the ping, and the distance.
	 * @param units
	 *            The units returned in either kInches or kMilliMeters
	 */
	public Ultrasonic(final int pingChannel, final int echoChannel, Unit units)
	{
		m_allocatedChannels = true;
		m_units = units;
		
		pingOutputChannel = pingChannel;
		echoInputChannel = echoChannel;
		
		initialize();
	}

	/**
	 * Create an instance of the Ultrasonic Sensor.
	 * This is designed to supchannel the Daventech SRF04 and Vex ultrasonic
	 * sensors. Default unit is inches.
	 *
	 * @param pingChannel
	 *            The digital output channel that sends the pulse to initiate
	 *            the sensor sending the ping.
	 * @param echoChannel
	 *            The digital input channel that receives the echo. The length
	 *            of time that the echo is high represents the round trip time
	 *            of the ping, and the distance.
	 */
	public Ultrasonic(final int pingChannel, final int echoChannel)
	{
		this(pingChannel, echoChannel, Unit.kInches);

	}

	/**
	 * Create an instance of an Ultrasonic Sensor from a DigitalInput for the
	 * echo channel and a DigitalOutput for the ping channel.
	 *
	 * @param pingChannel
	 *            The digital output object that starts the sensor doing a ping.
	 *            Requires a 10uS pulse to start.
	 * @param echoChannel
	 *            The digital input object that times the return pulse to
	 *            determine the range.
	 * @param units
	 *            The units returned in either kInches or kMilliMeters
	 */
	public Ultrasonic(DigitalOutput pingChannel, DigitalInput echoChannel,
			Unit units) {
		if (pingChannel == null || echoChannel == null) {
			throw new NullPointerException("Null Channel Provided");
		}
		m_allocatedChannels = false;
		
		pingOutputChannel = pingChannel.m_channel;
		echoInputChannel = echoChannel.channel;

		m_units = units;
		initialize();
	}

	/**
	 * Create an instance of an Ultrasonic Sensor from a DigitalInput for the
	 * echo channel and a DigitalOutput for the ping channel. Default unit is
	 * inches.
	 *
	 * @param pingChannel
	 *            The digital output object that starts the sensor doing a ping.
	 *            Requires a 10uS pulse to start.
	 * @param echoChannel
	 *            The digital input object that times the return pulse to
	 *            determine the range.
	 */
	public Ultrasonic(DigitalOutput pingChannel, DigitalInput echoChannel)
	{
		this(pingChannel, echoChannel, Unit.kInches);
	}

	/**
	 * Destructor for the ultrasonic sensor. Delete the instance of the
	 * ultrasonic sensor by freeing the allocated digital channels. If the
	 * system was in automatic mode (round robin), then it is stopped, then
	 * started again after this sensor is removed (provided this wasn't the last
	 * sensor).
	 */
	public synchronized void free()
	{

	}

	/**
	 * Turn Automatic mode on/off. When in Automatic mode, all sensors will fire
	 * in round robin, waiting a set time between each sensor.
	 *
	 * @param enabling
	 *            Set to true if round robin scheduling should start for all the
	 *            ultrasonic sensors. This scheduling method assures that the
	 *            sensors are non-interfering because no two sensors fire at the
	 *            same time. If another scheduling algorithm is preffered, it
	 *            can be implemented by pinging the sensors manually and waiting
	 *            for the results to come back.
	 */
	public void setAutomaticMode(boolean enabling)
	{
		//TODO implement this
	}

	/**
	 * Single ping to ultrasonic sensor. Send out a single ping to the
	 * ultrasonic sensor. This only works if automatic (round robin) mode is
	 * disabled. A single ping is sent out, and the counter should count the
	 * semi-period when it comes in. The counter is reset to make the current
	 * value invalid.
	 */
	public void ping()
	{
		//TODO implement this
	}

	/**
	 * Check if there is a valid range measurement. The ranges are accumulated
	 * in a counter that will increment on each edge of the echo (return)
	 * signal. If the count is not at least 2, then the range has not yet been
	 * measured, and is invalid.
	 *
	 * @return true if the range is valid
	 */
	public boolean isRangeValid()
	{
		return true;
	}

	/**
	 * Get the range in inches from the ultrasonic sensor.
	 *
	 * @return double Range in inches of the target returned from the ultrasonic
	 *         sensor. If there is no valid value yet, i.e. at least one
	 *         measurement hasn't completed, then return 0.
	 */
	public double getRangeInches()
	{
		//TODO implement this
		return 1;
	}

	/**
	 * Get the range in millimeters from the ultrasonic sensor.
	 *
	 * @return double Range in millimeters of the target returned by the
	 *         ultrasonic sensor. If there is no valid value yet, i.e. at least
	 *         one measurement hasn't complted, then return 0.
	 */
	public double getRangeMM() 
	{
		return getRangeInches() * 25.4;
	}

	/**
	 * Get the range in the current DistanceUnit for the PIDSource base object.
	 *
	 * @return The range in DistanceUnit
	 */
	public double pidGet()
	{
		switch (m_units.value) {
		case Unit.kInches_val:
			return getRangeInches();
		case Unit.kMillimeters_val:
			return getRangeMM();
		default:
			return 0.0;
		}
	}

	/**
	 * Set the current DistanceUnit that should be used for the PIDSource base
	 * object.
	 *
	 * @param units
	 *            The DistanceUnit that should be used.
	 */
	public void setDistanceUnits(Unit units) 
	{
		m_units = units;
	}

	/**
	 * Get the current DistanceUnit that is used for the PIDSource base object.
	 *
	 * @return The type of DistanceUnit that is being used.
	 */
	public Unit getDistanceUnits() 
	{
		return m_units;
	}

	/**
	 * Is the ultrasonic enabled
	 *
	 * @return true if the ultrasonic is enabled
	 */
	public boolean isEnabled() {
		return m_enabled;
	}

	/**
	 * Set if the ultrasonic is enabled
	 *
	 * @param enable
	 *            set to true to enable the ultrasonic
	 */
	public void setEnabled(boolean enable) {
		m_enabled = enable;
	}

	/*
	 * Live Window code, only does anything if live window is activated.
	 */
	public String getSmartDashboardType() {
		return "Ultrasonic";
	}

	private ITable m_table;

	/**
	 * {@inheritDoc}
	 */
	public void initTable(ITable subtable) {
		m_table = subtable;
		updateTable();
	}

	/**
	 * {@inheritDoc}
	 */
	public ITable getTable() {
		return m_table;
	}

	/**
	 * {@inheritDoc}
	 */
	public void updateTable() {
		if (m_table != null) {
			m_table.putNumber("Value", getRangeInches());
		}
	}

	/**
	 * {@inheritDoc}
	 */
	public void startLiveWindowMode() {
	}

	/**
	 * {@inheritDoc}
	 */
	public void stopLiveWindowMode() {
	}
}
